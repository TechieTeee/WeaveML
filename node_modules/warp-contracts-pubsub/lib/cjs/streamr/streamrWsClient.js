"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamrWsClient = void 0;
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const CONNECTION_DEFAULTS = {
    readHost: 'ws://read.streamr.warp.cc',
    readPort: 7170,
    writeHost: 'ws://write.streamr.warp.cc',
    writePort: 7180
};
var Status;
(function (Status) {
    Status[Status["connected"] = 0] = "connected";
    Status[Status["error"] = 1] = "error";
    Status[Status["closed"] = 2] = "closed";
    Status[Status["unexpected"] = 3] = "unexpected";
})(Status || (Status = {}));
class StreamrWsClient {
    static async create(connection) {
        const client = new StreamrWsClient(connection);
        await client.checkConnectionStatus();
        return client;
    }
    /**
     * Constructor can't be async. Use create method instead.
     * @param connection
     * @private
     */
    constructor(connection) {
        const c = { ...CONNECTION_DEFAULTS, ...connection };
        if (!c.direction) {
            throw new Error('Direction is required');
        }
        this.direction = c.direction;
        if (c.direction == 'sub' || c.direction == 'all') {
            this.subConnection = new isomorphic_ws_1.default(`${c.readHost}:${c.readPort}/streams/${encodeURIComponent(c.streamId)}/subscribe`);
            this.subStatus = this.getStatusPromise(this.subConnection);
        }
        if (c.direction == 'pub' || c.direction == 'all') {
            // eslint-disable-next-line prettier/prettier
            const pubUri = `${c.writeHost}:${c.writePort}/streams/${encodeURIComponent(c.streamId)}/publish?apiKey=${c.apiKey}`;
            this.pubConnection = new isomorphic_ws_1.default(pubUri);
            this.pubStatus = this.getStatusPromise(this.pubConnection);
        }
    }
    getStatusPromise(connection) {
        return new Promise((resolve, reject) => {
            connection.on('open', function connection() {
                resolve(Status.connected);
            });
            connection.on('error', (err) => {
                this.error = err;
                reject(Status.error);
            });
            connection.on('close', () => {
                this.error = 'Connection closed';
                reject(Status.closed);
            });
            connection.on('unexpected-response', (request) => {
                console.error(request);
                this.error = request;
                reject(Status.unexpected);
            });
        });
    }
    async pub(data, onError) {
        return this.pubConnection.send(JSON.stringify(data), onError);
    }
    sub(onMessage, onError) {
        if (this.subConnection.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error('Sub connection is not open. Status: ' + this.subConnection.readyState);
        }
        this.subConnection.on('message', (data) => onMessage(JSON.parse(data.toString())));
        this.subConnection.on('error', (err) => onError(err)).on('unexpected-response', (err) => onError(err));
    }
    close() {
        switch (this.direction) {
            case 'pub':
                this.pubConnection.close();
                break;
            case 'sub':
                this.subConnection.close();
                break;
            case 'all':
                this.subConnection.close();
                this.pubConnection.close();
                break;
        }
    }
    async checkConnectionStatus() {
        if (this.direction == 'pub' || this.direction == 'all') {
            const pubStatus = await this.pubStatus;
            if (pubStatus != Status.connected) {
                throw new Error('Pub connection error: ' + this.error);
            }
        }
        if (this.direction == 'sub' || this.direction == 'all') {
            const subStatus = await this.subStatus;
            if (subStatus != Status.connected) {
                throw new Error('Sub connection error: ' + this.error);
            }
        }
    }
}
exports.StreamrWsClient = StreamrWsClient;
//# sourceMappingURL=streamrWsClient.js.map