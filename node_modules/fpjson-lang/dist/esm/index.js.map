{
  "version": 3,
  "sources": ["../../src/index.mjs"],
  "sourcesContent": ["import * as R from \"ramda\"\n\nconst types = {\n  Object,\n  Array,\n  String,\n  Number,\n  Boolean,\n}\n\nconst isFunction = f => typeof f === \"function\"\n\nconst fn = (r, d = {}) => {\n  if (R.isNil(r)) return r\n\n  const _$ = R.curry(path => {\n    if (/^\\$/.test(path)) path = _var(R.tail(path), true)\n    return R.path(path.split(\".\"))(d)\n  })\n\n  const _var = R.curry((path, ignore) => _$(path))\n\n  const _let = R.curry((path, val) => {\n    let tar = d\n    if (/^\\$/.test(path)) path = _var(R.tail(path), true)\n    let _path = path.split(\".\")\n    for (let v of R.init(_path)) {\n      if (R.isNil(tar[v])) tar[v] = {}\n      tar = tar[v]\n    }\n    tar[R.last(_path)] = val\n    return val\n  })\n\n  let ret = null\n  if (isFunction(r[0])) {\n    const args = R.tail(r)\n    ret = r[0](...args)\n  } else if (R.is(Array)(r) && r.length === 1 && r[0] === \"__\") {\n    ret = R.__\n  } else if (r[0] === \"typ\") {\n    ret = types[r[1]]\n  } else if (r[0] === \"reg\") {\n    ret = new RegExp(...R.tail(r))\n  } else if (\n    R.is(Array)(r) &&\n    (R.includes(r[0])([\"let\", \"var\", \"$\"]) || isFunction(R[r[0]]))\n  ) {\n    ret = R.compose(\n      R.ifElse(\n        R.o(R.gt(R.__, 0), R.length),\n        R.apply(\n          r[0] === \"$\"\n            ? _$\n            : r[0] === \"var\"\n            ? _var\n            : r[0] === \"let\"\n            ? _let\n            : R[r[0]]\n        ),\n        R.always(R[r[0]])\n      ),\n      R.map(v => fn(v, d)),\n      R.tail\n    )(r)\n    ret = typeof ret === \"undefined\" ? [] : ret\n  } else if (R.is(Object)(r) && R.is(String)(r.var)) {\n    ret = R.path(r.var.split(\".\"))(d)\n  } else if (R.is(Array)(r) || R.is(Object)(r)) {\n    ret = R.map(v => fn(v, d))(r)\n  } else {\n    ret = r\n  }\n\n  let _ret = null\n  if (R.is(Array)(ret) && R.is(String)(ret[0]) && ret[0] === \"[]\") {\n    _ret = R.tail(ret)\n  } else {\n    _ret = isFunction(ret[0]) ? fn(ret, d) : ret\n  }\n\n  return _ret\n}\n\nexport default fn\n"],
  "mappings": "AAAA,UAAYA,MAAO,QAEnB,IAAMC,EAAQ,CACZ,OACA,MACA,OACA,OACA,OACF,EAEMC,EAAaC,GAAK,OAAOA,GAAM,WAE/BC,EAAK,CAACC,EAAGC,EAAI,CAAC,IAAM,CACxB,GAAM,QAAMD,CAAC,EAAG,OAAOA,EAEvB,IAAME,EAAO,QAAMC,IACb,MAAM,KAAKA,CAAI,IAAGA,EAAOC,EAAO,OAAKD,CAAI,EAAG,EAAI,GAC3C,OAAKA,EAAK,MAAM,GAAG,CAAC,EAAEF,CAAC,EACjC,EAEKG,EAAS,QAAM,CAACD,EAAME,IAAWH,EAAGC,CAAI,CAAC,EAEzCG,EAAS,QAAM,CAACH,EAAMI,IAAQ,CAClC,IAAIC,EAAMP,EACN,MAAM,KAAKE,CAAI,IAAGA,EAAOC,EAAO,OAAKD,CAAI,EAAG,EAAI,GACpD,IAAIM,EAAQN,EAAK,MAAM,GAAG,EAC1B,QAASO,KAAO,OAAKD,CAAK,EAClB,QAAMD,EAAIE,EAAE,IAAGF,EAAIE,GAAK,CAAC,GAC/BF,EAAMA,EAAIE,GAEZ,OAAAF,EAAM,OAAKC,CAAK,GAAKF,EACdA,CACT,CAAC,EAEGI,EAAM,KACV,GAAId,EAAWG,EAAE,EAAE,EAAG,CACpB,IAAMY,EAAS,OAAKZ,CAAC,EACrBW,EAAMX,EAAE,GAAG,GAAGY,CAAI,CACpB,MAAa,KAAG,KAAK,EAAEZ,CAAC,GAAKA,EAAE,SAAW,GAAKA,EAAE,KAAO,KACtDW,EAAQ,KACCX,EAAE,KAAO,MAClBW,EAAMf,EAAMI,EAAE,IACLA,EAAE,KAAO,MAClBW,EAAM,IAAI,OAAO,GAAK,OAAKX,CAAC,CAAC,EAE3B,KAAG,KAAK,EAAEA,CAAC,IACV,WAASA,EAAE,EAAE,EAAE,CAAC,MAAO,MAAO,GAAG,CAAC,GAAKH,EAAWF,EAAEK,EAAE,GAAG,IAE5DW,EAAQ,UACJ,SACE,IAAI,KAAK,KAAI,CAAC,EAAK,QAAM,EACzB,QACAX,EAAE,KAAO,IACLE,EACAF,EAAE,KAAO,MACTI,EACAJ,EAAE,KAAO,MACTM,EACAX,EAAEK,EAAE,GACV,EACE,SAAOL,EAAEK,EAAE,GAAG,CAClB,EACE,MAAIU,GAAKX,EAAGW,EAAGT,CAAC,CAAC,EACjB,MACJ,EAAED,CAAC,EACHW,EAAM,OAAOA,EAAQ,IAAc,CAAC,EAAIA,GAC7B,KAAG,MAAM,EAAEX,CAAC,GAAO,KAAG,MAAM,EAAEA,EAAE,GAAG,EAC9CW,EAAQ,OAAKX,EAAE,IAAI,MAAM,GAAG,CAAC,EAAEC,CAAC,EACrB,KAAG,KAAK,EAAED,CAAC,GAAO,KAAG,MAAM,EAAEA,CAAC,EACzCW,EAAQ,MAAID,GAAKX,EAAGW,EAAGT,CAAC,CAAC,EAAED,CAAC,EAE5BW,EAAMX,EAGR,IAAIa,EAAO,KACX,OAAM,KAAG,KAAK,EAAEF,CAAG,GAAO,KAAG,MAAM,EAAEA,EAAI,EAAE,GAAKA,EAAI,KAAO,KACzDE,EAAS,OAAKF,CAAG,EAEjBE,EAAOhB,EAAWc,EAAI,EAAE,EAAIZ,EAAGY,EAAKV,CAAC,EAAIU,EAGpCE,CACT,EAEOC,EAAQf",
  "names": ["R", "types", "isFunction", "f", "fn", "r", "d", "_$", "path", "_var", "ignore", "_let", "val", "tar", "_path", "v", "ret", "args", "_ret", "src_default"]
}
