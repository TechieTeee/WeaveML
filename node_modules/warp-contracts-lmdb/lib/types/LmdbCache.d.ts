import { CacheKey, CacheOptions, SortKeyCache, SortKeyCacheResult, PruneStats, BatchDBOp } from 'warp-contracts';
import { LmdbOptions } from './LmdbOptions';
import { SortKeyCacheRangeOptions } from 'warp-contracts/lib/types/cache/SortKeyCacheRangeOptions';
export declare class LmdbCache<V = any> implements SortKeyCache<V> {
    private readonly cacheOptions;
    private readonly lmdbOptions?;
    private readonly logger;
    private readonly ongoingTransactionMark;
    private readonly subLevelSeparator;
    private db;
    private rollbackBatch;
    constructor(cacheOptions: CacheOptions, lmdbOptions?: LmdbOptions);
    /**
     * Batch operations are all executed in one transaction using childTransaction.
     * For each put there is an old entries removal run.
     */
    batch(opStack: BatchDBOp<V>[]): Promise<void>;
    get(cacheKey: CacheKey, returnDeepCopy?: boolean): Promise<SortKeyCacheResult<V> | null>;
    getLast(key: string): Promise<SortKeyCacheResult<V> | null>;
    getLessOrEqual(key: string, sortKey: string): Promise<SortKeyCacheResult<V> | null>;
    private joinedKeyResultToSortKeyCache;
    put(cacheKey: CacheKey, value: V): Promise<void>;
    del(cacheKey: CacheKey): Promise<void>;
    private doPut;
    private dbEntryKey;
    private removeOldestEntries;
    delete(key: string): Promise<void>;
    private doDelete;
    open(): Promise<void>;
    close(): Promise<void>;
    dump(): Promise<any>;
    getLastSortKey(): Promise<string | null>;
    keys(sortKey: string, options?: SortKeyCacheRangeOptions): Promise<string[]>;
    storage<S>(): S;
    prune(entriesStored?: number): Promise<PruneStats>;
    begin(): Promise<void>;
    private checkPreviousTransactionFinished;
    commit(): Promise<void>;
    kvMap(sortKey: string, options?: SortKeyCacheRangeOptions): Promise<Map<string, V>>;
    rollback(): Promise<void>;
}
//# sourceMappingURL=LmdbCache.d.ts.map